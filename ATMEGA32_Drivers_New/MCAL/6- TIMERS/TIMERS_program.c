
/********************************************************************/
/********************************************************************/
/*********************** Author: Ziyad Mohammed   *******************/
/*********************** File  : TIMERS_Program.c *******************/
/*********************** Version: 1.00            *******************/
/********************************************************************/
/********************************************************************/

#include "STD_TYPES.h"
#include "BIT_MATH.h"
#include "DEFINES.h"

#include "TIMERS_interface.h"
#include "TIMERS_prv.h"
#include "TIMERS_cfg.h"
#include "TIMERS_reg.h"

static void (*TIMERS_pvCallBAckFuncArr[8])(void) = {NULL};

void TIMER_voidInit(void)
{
	/*										TIMER0											*/

#if TIMER0_STATE == TIMER0_ENABLE
#if TIMER0_u8_WAVEFORM_MODE == TIMER0_u8_NORMAL
	CLR_BIT(TCCR0,TCCR0_WGM00);
	CLR_BIT(TCCR0,TCCR0_WGM01);
#elif TIMER0_u8_WAVEFORM_MODE == TIMER0_u8_PWM_PHASE_CORRECT
	SET_BIT(TCCR0,TCCR0_WGM00);
	CLR_BIT(TCCR0,TCCR0_WGM01);
#elif TIMER0_u8_WAVEFORM_MODE == TIMER0_u8_CTC
	CLR_BIT(TCCR0,TCCR0_WGM00);
	SET_BIT(TCCR0,TCCR0_WGM01);
#elif TIMER0_u8_WAVEFORM_MODE == TIMER0_u8_FAST_PWM
	SET_BIT(TCCR0,TCCR0_WGM00);
	SET_BIT(TCCR0,TCCR0_WGM01);
#endif

#if	TIMER0_u8_OUTPUT_MODE == TIMER0_OC0_DISCONNECTED
	CLR_BIT(TCCR0,TCCR0_COM00);
	CLR_BIT(TCCR0,TCCR0_COM01);
#elif TIMER0_u8_OUTPUT_MODE == TIMER0_u8_OC0_TOGGLE
#if	TIMER0_u8_WAVEFORM_MODE == TIMER0_u8_PWM_PHASE_CORRECT || TIMER0_u8_WAVEFORM_MODE == TIMER0_u8_FAST_PWM
#warning ("CHOOSED UNAVAILABLE OPTION IN TIMER OUTPUT MODE!!")
#else
	SET_BIT(TCCR0,TCCR0_COM00);
	CLR_BIT(TCCR0,TCCR0_COM01);
#endif
#elif TIMER0_u8_OUTPUT_MODE == TIMER0_u8_OC0_CLEAR
	CLR_BIT(TCCR0,TCCR0_COM00);
	SET_BIT(TCCR0,TCCR0_COM01);
#elif TIMER0_u8_OUTPUT_MODE == TIMER0_u8_OC0_SET
	SET_BIT(TCCR0,TCCR0_COM00);
	SET_BIT(TCCR0,TCCR0_COM01);
#endif

#if TIMER0_u8_PRESCALLER == TIMER0_u8_STOP
	CLR_BIT(TCCR0,TCCR0_CS00);
	CLR_BIT(TCCR0,TCCR0_CS01);
	CLR_BIT(TCCR0,TCCR0_CS02);
#elif TIMER0_u8_PRESCALLER == TIMER0_u8_DIV_BY_1
	SET_BIT(TCCR0,TCCR0_CS00);
	CLR_BIT(TCCR0,TCCR0_CS01);
	CLR_BIT(TCCR0,TCCR0_CS02);
#elif TIMER0_u8_PRESCALLER == TIMER0_u8_DIV_BY_8
	CLR_BIT(TCCR0,TCCR0_CS00);
	SET_BIT(TCCR0,TCCR0_CS01);
	CLR_BIT(TCCR0,TCCR0_CS02);
#elif TIMER0_u8_PRESCALLER == TIMER0_u8_DIV_BY_64
	SET_BIT(TCCR0,TCCR0_CS00);
	SET_BIT(TCCR0,TCCR0_CS01);
	CLR_BIT(TCCR0,TCCR0_CS02);
#elif TIMER0_u8_PRESCALLER == TIMER0_u8_DIV_BY_256
	CLR_BIT(TCCR0,TCCR0_CS00);
	CLR_BIT(TCCR0,TCCR0_CS01);
	SET_BIT(TCCR0,TCCR0_CS02);
#elif TIMER0_u8_PRESCALLER == TIMER0_u8_DIV_BY_1024
	SET_BIT(TCCR0,TCCR0_CS00);
	CLR_BIT(TCCR0,TCCR0_CS01);
	SET_BIT(TCCR0,TCCR0_CS02);
#endif

#if TIMER0_u8_INTERRUPT == TIMER0_u8_ENABLE_INTERRUPT
#if TIMER0_u8_WAVEFORM_MODE == TIMER0_u8_NORMAL
	SET_BIT(TIMSK,TIMSK_TOIE0);
#elif TIMER0_u8_WAVEFORM_MODE == TIMER0_u8_CTC
	SET_BIT(TIMSK,TIMSK_OCIE0);
#endif

#endif
#endif

	/*										TIMER1											*/

#if TIMER1_STATE == TIMER1_ENABLE
#if TIMER1_u8_WAVEFORM_MODE == TIMER1_u8_NORMAL
	CLR_BIT(TCCR1A,TCCR1A_WGM10);
	CLR_BIT(TCCR1A,TCCR1A_WGM11);
	CLR_BIT(TCCR1B,TCCR1B_WGM12);
	CLR_BIT(TCCR1B,TCCR1B_WGM13);
#elif TIMER1_u8_WAVEFORM_MODE == TIMER1_u8_PWM_PHASE_CORRECT_8BIT
	SET_BIT(TCCR1A,TCCR1A_WGM10);
	CLR_BIT(TCCR1A,TCCR1A_WGM11);
	CLR_BIT(TCCR1B,TCCR1B_WGM12);
	CLR_BIT(TCCR1B,TCCR1B_WGM13);
#elif TIMER1_u8_WAVEFORM_MODE == TIMER1_u8_PWM_PHASE_CORRECT_9BIT
	CLR_BIT(TCCR1A,TCCR1A_WGM10);
	SET_BIT(TCCR1A,TCCR1A_WGM11);
	CLR_BIT(TCCR1B,TCCR1B_WGM12);
	CLR_BIT(TCCR1B,TCCR1B_WGM13);
#elif TIMER1_u8_WAVEFORM_MODE == TIMER1_u8_PWM_PHASE_CORRECT_10BIT
	SET_BIT(TCCR1A,TCCR1A_WGM10);
	SET_BIT(TCCR1A,TCCR1A_WGM11);
	CLR_BIT(TCCR1B,TCCR1B_WGM12);
	CLR_BIT(TCCR1B,TCCR1B_WGM13);
#elif TIMER1_u8_WAVEFORM_MODE == TIMER1_u8_CTC_OCR1A
	CLR_BIT(TCCR1A,TCCR1A_WGM10);
	CLR_BIT(TCCR1A,TCCR1A_WGM11);
	SET_BIT(TCCR1B,TCCR1B_WGM12);
	CLR_BIT(TCCR1B,TCCR1B_WGM13);
#elif TIMER1_u8_WAVEFORM_MODE == TIMER1_u8_FAST_PWM_8BIT
	SET_BIT(TCCR1A,TCCR1A_WGM10);
	CLR_BIT(TCCR1A,TCCR1A_WGM11);
	SET_BIT(TCCR1B,TCCR1B_WGM12);
	CLR_BIT(TCCR1B,TCCR1B_WGM13);
#elif TIMER1_u8_WAVEFORM_MODE == TIMER1_u8_FAST_PWM_9BIT
	CLR_BIT(TCCR1A,TCCR1A_WGM10);
	SET_BIT(TCCR1A,TCCR1A_WGM11);
	SET_BIT(TCCR1B,TCCR1B_WGM12);
	CLR_BIT(TCCR1B,TCCR1B_WGM13);
#elif TIMER1_u8_WAVEFORM_MODE == TIMER1_u8_FAST_PWM_10BIT
	SET_BIT(TCCR1A,TCCR1A_WGM10);
	SET_BIT(TCCR1A,TCCR1A_WGM11);
	SET_BIT(TCCR1B,TCCR1B_WGM12);
	CLR_BIT(TCCR1B,TCCR1B_WGM13);
#elif TIMER1_u8_WAVEFORM_MODE == TIMER1_u8_PWM_PHASE_FREQUANCY_CORRECT_ICR1
	CLR_BIT(TCCR1A,TCCR1A_WGM10);
	CLR_BIT(TCCR1A,TCCR1A_WGM11);
	CLR_BIT(TCCR1B,TCCR1B_WGM12);
	SET_BIT(TCCR1B,TCCR1B_WGM13);
#elif TIMER1_u8_WAVEFORM_MODE == TIMER1_u8_PWM_PHASE_FREQUANCY_CORRECT_OCR1A
	SET_BIT(TCCR1A,TCCR1A_WGM10);
	CLR_BIT(TCCR1A,TCCR1A_WGM11);
	CLR_BIT(TCCR1B,TCCR1B_WGM12);
	SET_BIT(TCCR1B,TCCR1B_WGM13);
#elif TIMER1_u8_WAVEFORM_MODE == TIMER1_u8_PWM_PHASE_CORRECT_ICR1
	CLR_BIT(TCCR1A,TCCR1A_WGM10);
	SET_BIT(TCCR1A,TCCR1A_WGM11);
	CLR_BIT(TCCR1B,TCCR1B_WGM12);
	SET_BIT(TCCR1B,TCCR1B_WGM13);
#elif TIMER1_u8_WAVEFORM_MODE == TIMER1_u8_PWM_PHASE_CORRECT_OCR1A
	SET_BIT(TCCR1A,TCCR1A_WGM10);
	SET_BIT(TCCR1A,TCCR1A_WGM11);
	CLR_BIT(TCCR1B,TCCR1B_WGM12);
	SET_BIT(TCCR1B,TCCR1B_WGM13);
#elif TIMER1_u8_WAVEFORM_MODE == TIMER1_u8_CTC_ICR1
	CLR_BIT(TCCR1A,TCCR1A_WGM10);
	CLR_BIT(TCCR1A,TCCR1A_WGM11);
	SET_BIT(TCCR1B,TCCR1B_WGM12);
	SET_BIT(TCCR1B,TCCR1B_WGM13);
#elif TIMER1_u8_WAVEFORM_MODE == TIMER1_u8_FAST_PWM_ICR1
	CLR_BIT(TCCR1A,TCCR1A_WGM10);
	SET_BIT(TCCR1A,TCCR1A_WGM11);
	SET_BIT(TCCR1B,TCCR1B_WGM12);
	SET_BIT(TCCR1B,TCCR1B_WGM13);
#elif TIMER1_u8_WAVEFORM_MODE == TIMER1_u8_FAST_PWM_OCR1A
	SET_BIT(TCCR1A,TCCR1A_WGM10);
	SET_BIT(TCCR1A,TCCR1A_WGM11);
	SET_BIT(TCCR1B,TCCR1B_WGM12);
	SET_BIT(TCCR1B,TCCR1B_WGM13);
#endif

#if TIMER1_CHANNEL_A_STATE == TIMER1_CHANNEL_A_ENABLE
#if	TIMER1_u8_OUTPUT_MODE == TIMER1_OC1_DISCONNECTED
	CLR_BIT(TCCR1A,TCCR1A_COM1A0);
	CLR_BIT(TCCR1A,TCCR1A_COM1A1);
#elif TIMER1_u8_OUTPUT_MODE == TIMER1_u8_OC1_TOGGLE
	SET_BIT(TCCR1A,TCCR1A_COM1A0);
	CLR_BIT(TCCR1A,TCCR1A_COM1A1);
#elif TIMER1_u8_OUTPUT_MODE == TIMER1_u8_OC1_CLEAR
	CLR_BIT(TCCR1A,TCCR1A_COM1A0);
	SET_BIT(TCCR1A,TCCR1A_COM1A1);
#elif TIMER1_u8_OUTPUT_MODE == TIMER1_u8_OC1_SET
	SET_BIT(TCCR1A,TCCR1A_COM1A0);
	SET_BIT(TCCR1A,TCCR1A_COM1A1);
#endif
#endif

#if TIMER1_CHANNEL_B_STATE	==		TIMER1_CHANNEL_B_ENABLE
#if	TIMER1_u8_OUTPUT_MODE == TIMER1_OC1_DISCONNECTED
	CLR_BIT(TCCR1A,TCCR1A_COM1B0);
	CLR_BIT(TCCR1A,TCCR1A_COM1B1);
#elif TIMER1_u8_OUTPUT_MODE == TIMER1_u8_OC1_TOGGLE
	SET_BIT(TCCR1A,TCCR1A_COM1B0);
	CLR_BIT(TCCR1A,TCCR1A_COM1B1);
#elif TIMER1_u8_OUTPUT_MODE == TIMER1_u8_OC1_CLEAR
	CLR_BIT(TCCR1A,TCCR1A_COM1B0);
	SET_BIT(TCCR1A,TCCR1A_COM1B1);
#elif TIMER1_u8_OUTPUT_MODE == TIMER1_u8_OC1_SET
	SET_BIT(TCCR1A,TCCR1A_COM1B0);
	SET_BIT(TCCR1A,TCCR1A_COM1B1);
#endif
#endif

#if TIMER1_u8_PRESCALLER == TIMER1_u8_STOP
	CLR_BIT(TCCR1B,TCCR1B_CS10);
	CLR_BIT(TCCR1B,TCCR1B_CS11);
	CLR_BIT(TCCR1B,TCCR1B_CS12);
#elif TIMER1_u8_PRESCALLER == TIMER1_u8_DIV_BY_1
	SET_BIT(TCCR1B,TCCR1B_CS10);
	CLR_BIT(TCCR1B,TCCR1B_CS11);
	CLR_BIT(TCCR1B,TCCR1B_CS12);
#elif TIMER1_u8_PRESCALLER == TIMER1_u8_DIV_BY_8
	CLR_BIT(TCCR1B,TCCR1B_CS10);
	SET_BIT(TCCR1B,TCCR1B_CS11);
	CLR_BIT(TCCR1B,TCCR1B_CS12);
#elif TIMER1_u8_PRESCALLER == TIMER1_u8_DIV_BY_64
	SET_BIT(TCCR1B,TCCR1B_CS10);
	SET_BIT(TCCR1B,TCCR1B_CS11);
	CLR_BIT(TCCR1B,TCCR1B_CS12);
#elif TIMER1_u8_PRESCALLER == TIMER1_u8_DIV_BY_256
	CLR_BIT(TCCR1B,TCCR1B_CS10);
	CLR_BIT(TCCR1B,TCCR1B_CS11);
	SET_BIT(TCCR1B,TCCR1B_CS12);
#elif TIMER1_u8_PRESCALLER == TIMER1_u8_DIV_BY_1024
	SET_BIT(TCCR1B,TCCR1B_CS10);
	CLR_BIT(TCCR1B,TCCR1B_CS11);
	SET_BIT(TCCR1B,TCCR1B_CS12);
#endif

	/*ICU Initialization.*/
#if TIMER1_u8_INPUT_CAPTURE == TIMER1_u8_RISING_INPUT_CAPTURE
	SET_BIT(TCCR1B,TCCR1B_ICES1);
#elif TIMER1_u8_INPUT_CAPTURE == TIMER1_u8_FALLING_INPUT_CAPTURE
	CLR_BIT(TCCR1B,TCCR1B_ICES1);
#else
#error Wrong TIMER1_u8_INPUT_CAPTURE Configuration Option.
#endif
#if ICU_TIMER1_U8_INT_STATE == ICU_TIMER1_U8_INT_ENABLE
	SET_BIT(TIMSK,TIMSK_TICIE1);
#elif ICU_TIMER1_U8_INT_STATE == ICU_TIMER1_U8_INT_ENABLE
	CLR_BIT(TIMSK,TIMSK_TICIE1);
#else
#error Wrong ICU_TIMER1_U8_INT_STATE Configuration Option.
#endif
#endif

	/*										TIMER2											*/

#if TIMER2_STATE == TIMER2_ENABLE
#if TIMER2_u8_WAVEFORM_MODE == TIMER2_u8_NORMAL
	CLR_BIT(TCCR2,TCCR2_WGM20);
	CLR_BIT(TCCR2,TCCR2_WGM21);
#elif TIMER2_u8_WAVEFORM_MODE == TIMER2_u8_PWM_PHASE_CORRECT
	SET_BIT(TCCR2,WGM20);
	CLR_BIT(TCCR2,WGM21);
#elif TIMER2_u8_WAVEFORM_MODE == TIMER2_u8_CTC
	CLR_BIT(TCCR2,WGM20);
	SET_BIT(TCCR2,WGM21);
#elif TIMER2_u8_WAVEFORM_MODE == TIMER2_u8_FAST_PWM
	SET_BIT(TCCR2,WGM20);
	SET_BIT(TCCR2,WGM21);
#else
#error Wrong TIMER2_u8_WAVEFORM_MODE Configuration.
#endif

#if	TIMER2_u8_OUTPUT_MODE == TIMER2_OC2_DISCONNECTED
	CLR_BIT(TCCR2,TCCR2_COM20);
	CLR_BIT(TCCR2,TCCR2_COM21);
#elif TIMER2_u8_OUTPUT_MODE == TIMER2_u8_OC2_TOGGLE
#if	TIMER2_u8_WAVEFORM_MODE == TIMER2_u8_PWM_PHASE_CORRECT || TIMER2_u8_WAVEFORM_MODE == TIMER2_u8_FAST_PWM
#warning ("CHOOSED UNAVAILABLE OPTION IN TIMER OUTPUT MODE!!")
#else
	SET_BIT(TCCR2,COM20);
	CLR_BIT(TCCR2,COM21);
#endif
#elif TIMER2_u8_OUTPUT_MODE == TIMER2_u8_OC2_CLEAR
	CLR_BIT(TCCR2,COM20);
	SET_BIT(TCCR2,COM21);
#elif TIMER2_u8_OUTPUT_MODE == TIMER2_u8_OC2_SET
	SET_BIT(TCCR2,COM20);
	SET_BIT(TCCR2,COM21);
#endif

#if TIMER2_u8_PRESCALLER == TIMER2_u8_STOP
	CLR_BIT(TCCR2,CS20);
	CLR_BIT(TCCR2,CS21);
	CLR_BIT(TCCR2,CS22);
#elif TIMER2_u8_PRESCALLER == TIMER2_u8_DIV_BY_1
	SET_BIT(TCCR2,TCCR2_CS20);
	CLR_BIT(TCCR2,TCCR2_CS21);
	CLR_BIT(TCCR2,TCCR2_CS22);
#elif TIMER2_u8_PRESCALLER == TIMER2_u8_DIV_BY_8
	CLR_BIT(TCCR2,CS20);
	SET_BIT(TCCR2,CS21);
	CLR_BIT(TCCR2,CS22);
#elif TIMER2_u8_PRESCALLER == TIMER2_u8_DIV_BY_32
	SET_BIT(TCCR2,CS20);
	SET_BIT(TCCR2,CS21);
	CLR_BIT(TCCR2,CS22);
#elif TIMER2_u8_PRESCALLER == TIMER2_u8_DIV_BY_64
	CLR_BIT(TCCR2,CS20);
	CLR_BIT(TCCR2,CS21);
	SET_BIT(TCCR2,CS22);
#elif TIMER2_u8_PRESCALLER == TIMER2_u8_DIV_BY_128
	SET_BIT(TCCR2,CS20);
	CLR_BIT(TCCR2,CS21);
	SET_BIT(TCCR2,CS22);
#elif TIMER2_u8_PRESCALLER == TIMER2_u8_DIV_BY_256
	CLR_BIT(TCCR2,CS20);
	SET_BIT(TCCR2,CS21);
	SET_BIT(TCCR2,CS22);
#elif TIMER2_u8_PRESCALLER == TIMER2_u8_DIV_BY_1024
	SET_BIT(TCCR2,CS20);
	SET_BIT(TCCR2,CS21);
	SET_BIT(TCCR2,CS22);
#endif

#if TIMER2_u8_INTERRUPT == TIMER2_u8_ENABLE_INTERRUPT
#if TIMER2_u8_WAVEFORM_MODE == TIMER2_u8_NORMAL
	SET_BIT(TIMSK,TIMSK_TOIE2);
#elif TIMER2_u8_WAVEFORM_MODE == TIMER2_u8_CTC
	SET_BIT(TIMSK,TIMSK_OCIE2);
#endif

#endif
#endif

}

/*										TIMER0											*/

void TIMER0_voidSetOVFRegister(uint8 Copy_u8Value)
{
	TCNT0 = Copy_u8Value;
}

void TIMER0_voidSetCTCRegister(uint8 Copy_u8Value)
{
	OCR0 = Copy_u8Value;
}

void TIMER0_voidEnableOVFINT(void)
{
	SET_BIT(TIMSK , TIMSK_TOIE0);
}

void TIMER0_voidDisableOVFINT(void)
{
	CLR_BIT(TIMSK , TIMSK_TOIE0);
}

void TIMER0_voidClearOVFFlag(void)
{
	SET_BIT(TIFR , TIFR_TOV0);

}

void TIMER0_voidEnableCTCINT(void)
{
	SET_BIT(TIMSK , TIMSK_OCIE0);
}

void TIMER0_voidDisableCTCINT(void)
{
	CLR_BIT(TIMSK , TIMSK_OCIE0);
}

void TIMER0_voidClearCTCFlag(void)
{
	SET_BIT(TIFR , TIFR_OCF0);
}

uint8 TIMERS_u8SetCallBack(TIMERS_Int_SRC_t Copy_u8TmrIntSource, void (*Copy_pvCallBackFunc)(void))
{
	Timer_Error_t Local_u8ErrorState = TMR_OK;
	if(Copy_pvCallBackFunc != NULL)
	{
		TIMERS_pvCallBAckFuncArr[Copy_u8TmrIntSource]=Copy_pvCallBackFunc;
	}
	else
	{
		Local_u8ErrorState = TMR_PTR_ERROR;
	}
	return Local_u8ErrorState;
}


void TIMER0_voidForceOutputCompare(void)
{
	SET_BIT(TCCR0,TCCR0_FOC0);
}

/*										TIMER1											*/


void TIMER1_voidSetOVFRegister(uint16 Copy_u16Value)
{
	TCNT1 = Copy_u16Value;
}

void TIMER1_voidChannelASetCTCRegister(uint16 Copy_u16Value)
{
	OCR1A	= Copy_u16Value;
}

void TIMER1_voidChannelBSetCTCRegister(uint16 Copy_u16Value)
{
	OCR1B	= Copy_u16Value;
}

uint16 TIMER1_u16InputCaptureValue(void)
{
	return ICR1;
}

void TIMER1_voidEnableOVFINT(void)
{
	SET_BIT(TIMSK,TIMSK_TOIE1);
}

void TIMER1_voidDisableOVFINT(void)
{
	CLR_BIT(TIMSK,TIMSK_TOIE1);
}

void TIMER1_voidClearOVFFlag(void)
{
	SET_BIT(TIFR,TIFR_TOV1);
}

void TIMER1_voidChannelAEnableCTCINT(void)
{
	SET_BIT(TIMSK,TIMSK_OCIE1A);
}

void TIMER1_voidChannelADisableCTCINT(void)
{
	CLR_BIT(TIMSK,TIMSK_OCIE1A);
}

void TIMER1_voidChannelAClearCTCFlag(void)
{
	SET_BIT(TIFR,TIFR_OCF1A);
}

void TIMER1_voidChannelBEnableCTCINT(void)
{
	SET_BIT(TIMSK,TIMSK_OCIE1B);
}

void TIMER1_voidChannelBDisableCTCINT(void)
{
	CLR_BIT(TIMSK,TIMSK_OCIE1B);
}

void TIMER1_voidChannelBClearCTCFlag(void)
{
	SET_BIT(TIFR,TIFR_OCF1B);
}
/*Input Capture Unit Interrupt.*/
void TIMER1_voidEnableInputCaptureINT(void)
{
	SET_BIT(TIMSK,TIMSK_TICIE1);
}

void TIMER1_voidDisableInputCaptureINT(void)
{
	CLR_BIT(TIMSK,TIMSK_TICIE1);
}

void TIMER1_voidClearInputCaptureFlag(void)
{
	SET_BIT(TIFR,TIFR_ICF1);
}

void TIMER1_voidChannelAForceOutputCompare(void)
{
	SET_BIT(TCCR1A,TCCR1A_FOC1A);
}

void TIMER1_voidChannelBForceOutputCompare(void)
{
	SET_BIT(TCCR1A,TCCR1A_FOC1B);
}

Timers_ErrorState_t ICU_u8Timer1SetTriggerSrc(uint8 Copy_u8TriggerSrc)
{
	Timers_ErrorState_t Local_u8ErrorState = TIMER1_ICU_TRIGGER_SOURCE_OK;
	switch(Copy_u8TriggerSrc)
	{
	case TIMER1_u8_RISING_INPUT_CAPTURE:
		SET_BIT(TCCR1B,TCCR1B_ICES1);
		break;
	case TIMER1_u8_FALLING_INPUT_CAPTURE:
		CLR_BIT(TCCR1B,TCCR1B_ICES1);
	break;
	default:
		Local_u8ErrorState = TIMER1_ICU_TRIGGER_SOURCE_INTERRUPT_TRIGGER_ERROR;
		break;
	}
	return Local_u8ErrorState;
}

/*										TIMER2											*/

void TIMER2_voidSetOVFRegister(uint8 Copy_u8Value)
{
	TCNT2 = Copy_u8Value;
}

void TIMER2_voidSetCTCRegister(uint8 Copy_u8Value)
{
	OCR2 = Copy_u8Value;
}

void TIMER2_voidEnableOVFINT(void)
{
	SET_BIT(TIMSK , TIMSK_TOIE2);
}

void TIMER2_voidDisableOVFINT(void)
{
	CLR_BIT(TIMSK , TIMSK_TOIE2);
}

void TIMER2_voidClearOVFFlag(void)
{
	SET_BIT(TIFR , TIFR_TOV2);
}

void TIMER2_voidEnableCTCINT(void)
{
	SET_BIT(TIMSK , TIMSK_OCIE2);
}

void TIMER2_voidDisableCTCINT(void)
{
	CLR_BIT(TIMSK , TIMSK_OCIE2);
}

void TIMER2_voidClearCTCFlag(void)
{
	SET_BIT(TIFR , TIFR_OCF2);
}

void TIMER2_voidForceOutputCompare(void)
{
	SET_BIT(TCCR2,TCCR2_FOC2);
}


void __vector_4(void)
{
	TIMERS_pvCallBAckFuncArr[TIMER2_CTC_CALLBACK_INDEX]();
	TIMER2_voidClearCTCFlag();
}

void __vector_5(void)
{
	TIMERS_pvCallBAckFuncArr[TIMER2_OVF_CALLBACK_INDEX]();
	TIMER2_voidClearOVFFlag();
}

void __vector_6(void)
{
	TIMERS_pvCallBAckFuncArr[TIMER1_INPUT_CAPTURE_CALLBACK_INDEX]();
	TIMER1_voidClearInputCaptureFlag();
}

void __vector_7(void)
{
	TIMERS_pvCallBAckFuncArr[TIMER1_CTC_CHANNEL_A_CALLBACK_INDEX]();
	TIMER1_voidChannelAClearCTCFlag();
}

void __vector_8(void)
{
	TIMERS_pvCallBAckFuncArr[TIMER1_CTC_CHANNEL_B_CALLBACK_INDEX]();
	TIMER1_voidChannelBClearCTCFlag();
}

void __vector_9(void)
{
	TIMERS_pvCallBAckFuncArr[TIMER1_OVF_CALLBACK_INDEX]();
	TIMER1_voidClearOVFFlag();
}

void __vector_11(void)
{
	TIMERS_pvCallBAckFuncArr[TIMER0_OVF_CALLBACK_INDEX]();
	TIMER0_voidClearOVFFlag();
}

void __vector_10(void)
{
	TIMERS_pvCallBAckFuncArr[TIMER0_CTC_CALLBACK_INDEX]();
	TIMER0_voidClearCTCFlag();
}
